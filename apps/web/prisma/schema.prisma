generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                               String                     @id @default(cuid())
  email                            String                     @unique
  name                             String?
  role                             Role                       @default(GUEST)
  country                          String?
  createdAt                        DateTime                   @default(now())
  lastLoginAt                      DateTime?
  emailVerified                    DateTime?
  identityLastVerifiedAt           DateTime?
  /// Vérification d'identité Stripe Identity (Lok'Room)
  identityStatus                   IdentityVerificationStatus @default(UNVERIFIED)
  identityStripeSessionId          String?
  /// Mot de passe hashé (bcrypt) - null si compte créé via OAuth uniquement
  passwordHash                     String?
  /// Token de réinitialisation de mot de passe
  resetToken                       String?                    @unique
  resetTokenExpiresAt              DateTime?
  /// Code de vérification email pour inscription
  emailVerificationCode            String?
  emailVerificationCodeExpiresAt   DateTime?
  accounts                         Account[]
  accountDeletionRequest           AccountDeletionRequest[]
  adminNotes                       AdminNote[]
  auditLogs                        AuditLog[]
  cancelledBookings                Booking[]                  @relation("BookingCancelledBy")
  bookings                         Booking[]                  @relation("BookingGuest")
  guestConversations               Conversation[]             @relation("GuestConversations")
  hostConversations                Conversation[]             @relation("HostConversations")
  dataExportRequests               DataExportRequest[]
  Dispute_Dispute_againstIdToUser  Dispute[]                  @relation("Dispute_againstIdToUser")
  disputesAssigned                 Dispute[]                  @relation("DisputeAdmin")
  disputesOpened                   Dispute[]                  @relation("DisputeOpener")
  disputeEvidence                  DisputeEvidence[]
  disputeMessages                  DisputeMessage[]
  Experience                       Experience[]
  ExperienceBooking                ExperienceBooking[]
  ExperienceReview                 ExperienceReview[]
  favorites                        Favorite[]
  hostProfile                      HostProfile?
  Listing                          Listing[]
  ListingModeration                ListingModeration[]
  ListingReport                    ListingReport[]
  messages                         Message[]
  notifications                    Notification[]
  notificationPreferences          NotificationPreference?
  passwordHistory                  PasswordHistory[]
  PromoCode                        PromoCode[]
  promoCodeUsages                  PromoCodeUsage[]
  PushSubscription                 PushSubscription[]
  referralsReceived                Referral?                  @relation("ReferralsReceived")
  referralsMade                    Referral[]                 @relation("ReferralsMade")
  ReferralCode                     ReferralCode?
  reviewsWritten                   Review[]                   @relation("ReviewAuthor")
  reviewsReceived                  Review[]                   @relation("ReviewTarget")
  searchHistory                    SearchHistory[]
  sessions                         Session[]
  SystemConfig                     SystemConfig[]
  UserBadge                        UserBadge[]
  UserBan_UserBan_bannedByIdToUser UserBan[]                  @relation("UserBan_bannedByIdToUser")
  UserBan_UserBan_userIdToUser     UserBan[]                  @relation("UserBan_userIdToUser")
  UserConsent                      UserConsent[]
  UserPresence                     UserPresence?
  profile                          UserProfile?
  wallet                           Wallet?
  WalletLedger                     WalletLedger[]
  wishlists                        Wishlist[]
  hostKit                           HostKit?
  twoFactorSecret                   TwoFactorSecret?
  twoFactorLogs                     TwoFactorLog[]
  /// Conversations de support (en tant qu'utilisateur)
  supportConversations              SupportConversation[]
  /// Conversations de support assignées (en tant qu'admin)
  assignedSupportConversations      SupportConversation[] @relation("SupportAdmin")
  /// Messages de support envoyés
  supportMessagesSent               SupportMessage[]      @relation("SupportMessageSender")
  /// Webhooks créés par l'utilisateur
  webhooks                          Webhook[]
  /// Recommandations personnalisées
  recommendations                   UserRecommendation[]
  /// Comportements trackés
  behaviors                         UserBehavior[]
}

/// Secret TOTP pour l'authentification à deux facteurs
model TwoFactorSecret {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Secret TOTP chiffré
  secret      String
  /// Codes de secours hashés
  backupCodes String[]
  /// 2FA activé ou non
  enabled     Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
}

/// Logs des tentatives 2FA
model TwoFactorLog {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Méthode utilisée: TOTP, BACKUP_CODE, SMS
  method    String
  /// Succès ou échec
  success   Boolean
  /// Adresse IP
  ipAddress String?
  /// User Agent
  userAgent String?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

/// Historique des mots de passe pour empêcher la réutilisation
model PasswordHistory {
  id           String   @id @default(cuid())
  userId       String
  passwordHash String
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserProfile {
  id           String    @id @default(cuid())
  userId       String    @unique
  avatarUrl    String?
  ratingAvg    Float     @default(0)
  ratingCount  Int       @default(0)
  addressLine1 String?
  addressLine2 String?
  birthDate    DateTime?
  city         String?
  country      String?
  /// Champs supplémentaires pour pré-remplir Stripe / profil Lok'Room
  firstName    String?
  lastName     String?
  phone        String?
  postalCode   String?
  province     String?
  /// Adresse postale (si différente de l'adresse résidentielle)
  postalAddressLine1 String?
  postalAddressLine2 String?
  postalAddressCity  String?
  postalAddressPostalCode String?
  postalAddressCountry String?
  postalAddressProvince String?
  postalAddressSameAsResidential Boolean @default(true)
  /// Contact d'urgence
  emergencyContactName  String?
  emergencyContactPhone String?
  emergencyContactRelation String?
  /// Preferences de traduction automatique des messages
  preferredLanguage String  @default("fr")
  autoTranslate     Boolean @default(true)
  user         User      @relation(fields: [userId], references: [id])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Listing {
  id                 String             @id @default(cuid())
  title              String
  description        String
  /// Prix par nuit / par jour (frontend décidera comment l'afficher)
  price              Float
  country            String
  /// Ville : obligatoire (défaut vide pour anciennes lignes)
  city               String             @default("")
  createdAt          DateTime           @default(now())
  ownerId            String
  currency           Currency           @default(EUR)
  province           ProvinceCA?
  /// Adresse exacte de l'espace (jamais affichée publiquement)
  addressFull        String             @default("")
  /// Coordonnées exactes
  lat                Float              @default(0)
  /// Coordonnées "publiques" (approx)
  latPublic          Float              @default(0)
  lng                Float              @default(0)
  lngPublic          Float              @default(0)
  /// Ligne d'adresse principale (numéro + rue)
  addressLine1       String?
  /// ID du lieu renvoyé par le provider
  mapPlaceId         String?
  /// Provider utilisé
  mapProvider        MapProvider        @default(GOOGLE)
  /// Code postal
  postalCode         String?
  /// Prix à l'heure (optionnel, si l'espace est louable à l'heure)
  hourlyPrice        Float?
  /// Réservation instantanée possible ?
  isInstantBook      Boolean            @default(false)
  maxDurationHours   Int?
  /// Capacité de l'espace (nombre de personnes max)
  maxGuests          Int?
  maxNights          Int?
  /// Contraintes de durée pour les réservations à l'heure
  minDurationHours   Int?
  /// Contraintes de durée pour les réservations à la journée / nuitée
  minNights          Int?
  /// Mode de tarification (à l'heure, à la journée, ou les deux)
  pricingMode        PricingMode        @default(DAILY)
  /// Type d'espace principal (chambre, bureau, parking, studio, etc.)
  type               ListingType        @default(OTHER)
  /// Nombre de salles de bain
  bathrooms          Int?
  /// Capacités spécifiques selon le type d'espace
  /// Nombre de lits (logements)
  beds               Int?
  /// Type personnalisé si type = OTHER (ex: "Atelier", "Cave", etc.)
  customType         String?
  /// Nombre de bureaux (coworking/office)
  desks              Int?
  /// Réduction pour 3+ jours
  discountDays3Plus  Int?
  /// Réductions pour réservations multiples (en pourcentage)
  /// Réduction pour 3+ heures
  discountHours3Plus Int?
  /// Réduction pour 6+ heures
  discountHours6Plus Int?
  /// Réduction mensuelle
  discountMonthly    Int?
  /// Réduction hebdomadaire
  discountWeekly     Int?
  /// Nombre de places (parking/garage)
  parkings           Int?
  /// Région/département pour la France
  regionFR           String?
  /// Caractéristiques de l'espace (tags descriptifs)
  spaceFeatures      String[]           @default([])
  /// Types d'espace additionnels (multi-catégorie, ex: HOUSE + STUDIO)
  additionalTypes    String[]           @default([])
  isActive           Boolean            @default(true)
  rating             Float              @default(0)
  updatedAt          DateTime           @default(now())
  viewCount          Int                @default(0)

  // === CONFIGURATION DÉTAILLÉE ===

  /// Chambres et lits (pour APARTMENT, HOUSE, ROOM)
  bedrooms           Int?
  /// Configuration détaillée des lits par chambre (JSON)
  bedConfiguration   Json?
  /// Salles de bain complètes
  bathroomsFull      Int?
  /// Salles d'eau (sans baignoire)
  bathroomsHalf      Int?
  /// Salles de bain partagées
  bathroomsShared    Boolean            @default(false)

  /// Type d'accès à l'espace
  spaceType          SpaceAccessType    @default(ENTIRE_PLACE)

  /// Espaces (pour HOUSE)
  floors             Int?
  hasGarden          Boolean            @default(false)
  gardenSize         Int?
  hasPool            Boolean            @default(false)
  poolType           String?
  poolHeated         Boolean            @default(false)
  hasSpa             Boolean            @default(false)
  hasTerrace         Boolean            @default(false)
  terraceSize        Int?
  garageSpaces       Int?

  /// Studio spécifique
  studioType         String?
  studioHeight       Float?
  hasGreenScreen     Boolean            @default(false)
  hasSoundproofing   Boolean            @default(false)

  /// Parking/Garage spécifique
  parkingType        String?
  parkingCovered     Boolean            @default(false)
  parkingSecured     Boolean            @default(false)
  parkingLength      Float?
  parkingWidth       Float?
  parkingHeight      Float?
  hasEVCharger       Boolean            @default(false)

  // === TARIFICATION AVANCÉE ===

  /// Incréments horaires (30 ou 60 minutes)
  hourlyIncrement    Int                @default(60)
  /// Durée minimum en minutes
  minDurationMinutes Int?
  /// Durée maximum en minutes
  maxDurationMinutes Int?

  /// Préavis minimum (jours)
  advanceNoticeDays  Int                @default(1)
  /// Réservation max X jours à l'avance
  maxAdvanceBookingDays Int?

  /// Frais supplémentaires
  cleaningFee        Float?
  extraGuestFee      Float?
  extraGuestThreshold Int?

  /// Weekend pricing
  weekendPriceMultiplier Float?

  // === RÉDUCTIONS AVANCÉES ===

  /// Réductions horaires supplémentaires
  discountHours2Plus Int?
  discountHours4Plus Int?
  discountHours8Plus Int?

  /// Réductions journalières supplémentaires
  discountDays2Plus  Int?
  discountDays5Plus  Int?
  discountDays14Plus Int?

  /// Réductions stratégiques
  lastMinuteDiscount Int?
  lastMinuteDiscountDays Int?
  earlyBirdDiscount  Int?
  earlyBirdDiscountDays Int?
  firstBookingDiscount Int?

  // === DESCRIPTION ENRICHIE ===

  spaceDescription   String?
  guestAccessDescription String?
  neighborhoodDescription String?
  transitDescription String?
  notesDescription   String?
  highlights         String[]           @default([])

  // === RÈGLES DE LA MAISON ===

  houseRules         String[]           @default([])
  customHouseRules   String?
  checkInStart       String?
  checkInEnd         String?
  checkOutTime       String?
  selfCheckIn        Boolean            @default(false)
  checkInMethod      CheckInMethod?

  /// Politiques
  petsAllowed        Boolean            @default(false)
  petTypes           String[]           @default([])
  petFee             Float?
  smokingAllowed     Boolean            @default(false)
  eventsAllowed      Boolean            @default(false)
  childrenAllowed    Boolean            @default(true)

  quietHoursStart    String?
  quietHoursEnd      String?

  bookings           Booking[]
  calendar           CalendarBlock[]
  CalendarExport     CalendarExport?
  CalendarSync       CalendarSync[]
  conversations      Conversation[]
  DynamicPrice       DynamicPrice[]
  favorites          Favorite[]
  owner              User               @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  amenities          ListingAmenity[]
  images             ListingImage[]
  ListingModeration  ListingModeration?
  ListingReport      ListingReport[]
  reviews            Review[]
  instantBookSettings InstantBookSettings?
  securityDepositPolicy SecurityDepositPolicy?
  /// Recommandations utilisant ce listing
  recommendations       UserRecommendation[]
  /// Comportements liés à ce listing
  behaviors             UserBehavior[]

  @@index([ownerId])
  @@index([createdAt])
  @@index([country, province, city])
  @@index([mapPlaceId])
}

model ListingImage {
  id        String  @id @default(cuid())
  url       String
  listingId String
  /// Image de couverture de l’annonce ?
  isCover   Boolean @default(false)
  /// Ordre d’affichage des images (0, 1, 2, …)
  position  Int     @default(0)
  height    Int?
  /// Dimensions de l’image (optionnel, utile pour optimisation / thumbnails)
  width     Int?
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId])
  @@index([listingId, position])
  @@index([listingId, isCover])
}

model Favorite {
  id         String    @id @default(cuid())
  userId     String
  listingId  String
  createdAt  DateTime  @default(now())
  wishlistId String?
  listing    Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  wishlist   Wishlist? @relation(fields: [wishlistId], references: [id])

  @@unique([userId, listingId])
  @@index([listingId])
  @@index([userId])
  @@index([wishlistId])
}

model Wishlist {
  id        String     @id @default(cuid())
  name      String
  userId    String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  favorites Favorite[]
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Booking {
  id                     String            @id @default(cuid())
  listingId              String
  /// Voyageur (guest)
  guestId                String
  /// Pour les réservations à la journée / nuitée
  startDate              DateTime
  endDate                DateTime
  /// Prix de base de la réservation (hors frais Lok'Room), dans la devise de l'annonce
  totalPrice             Float
  currency               Currency
  status                 BookingStatus     @default(PENDING)
  createdAt              DateTime          @default(now())
  /// Infos d'annulation / refund
  cancelledAt            DateTime?
  cancelledByUserId      String?
  /// Montant total remboursé au client (en cents, toutes devises confondues)
  refundAmountCents      Int?
  /// Charge principale (remplie via webhook payment_intent.succeeded)
  stripeChargeId         String?
  /// Stripe PaymentIntent (rempli au moment de la création)
  stripePaymentIntentId  String?
  guestFeeCents          Int               @default(0)
  /// Détail des frais Lok'Room (snapshot en cents au moment de la création)
  hostFeeCents           Int               @default(0)
  platformNetCents       Int               @default(0)
  stripeFeeEstimateCents Int               @default(0)
  taxOnGuestFeeCents     Int               @default(0)
  endTimeMinutes         Int?
  /// Mode de tarification utilisé pour cette réservation (heure ou jour)
  pricingMode            PricingMode
  /// Pour les réservations à l'heure :
  /// heures de début/fin en minutes depuis minuit (dans le fuseau du listing)
  /// ex : 9h30 -> 570 ; 13h00 -> 780
  startTimeMinutes       Int?
  timezone               String?
  /// Provider de paiement utilisé (STRIPE par défaut, PAYPAL si PayPal)
  paymentProvider        PaymentProvider   @default(STRIPE)
  cancelledByUser        User?             @relation("BookingCancelledBy", fields: [cancelledByUserId], references: [id])
  guest                  User              @relation("BookingGuest", fields: [guestId], references: [id])
  listing                Listing           @relation(fields: [listingId], references: [id], onDelete: Cascade)
  calendarBlocks         CalendarBlock[]
  conversations          Conversation[]    @relation("BookingConversations")
  disputes               Dispute[]
  reviews                Review[]
  securityDeposit        SecurityDeposit?
  /// Transactions PayPal associées
  paypalTransactions     PayPalTransaction[]

  @@index([listingId, startDate, endDate])
  @@index([guestId, createdAt])
  @@index([stripePaymentIntentId])
}

model Review {
  id           String       @id @default(cuid())
  bookingId    String
  listingId    String
  /// Auteur de l'avis (guest OU host)
  authorId     String
  /// Utilisateur visé par l'avis (souvent l'hôte, parfois le guest)
  targetUserId String
  /// Note globale 1–5
  rating       Int
  /// Commentaire libre
  comment      String?
  /// Réponse de l'hôte/voyageur à l'avis
  response     String?
  responseAt   DateTime?
  /// Type d'avis (guest vers host, ou host vers guest)
  type         ReviewType   @default(GUEST_TO_HOST)
  /// Statut de l'avis (publié, en attente, signalé, supprimé)
  status       ReviewStatus @default(PUBLISHED)
  /// Sous-notes détaillées (style Airbnb) - pour les avis de voyageurs
  ratingCleanliness    Int?  /// Propreté (1-5)
  ratingAccuracy       Int?  /// Exactitude de l'annonce (1-5)
  ratingCommunication  Int?  /// Communication avec l'hôte (1-5)
  ratingLocation       Int?  /// Emplacement (1-5)
  ratingCheckin        Int?  /// Arrivée (1-5)
  ratingValue          Int?  /// Rapport qualité/prix (1-5)
  /// Sous-notes pour les avis d'hôtes sur les voyageurs
  ratingRespect        Int?  /// Respect des règles (1-5)
  ratingTidiness       Int?  /// Propreté laissée (1-5)
  /// Points forts mentionnés (tags)
  highlights   String[]     @default([])
  /// L'avis recommande-t-il cet espace/voyageur ?
  wouldRecommend Boolean    @default(true)
  /// Photos jointes à l'avis
  photos       ReviewPhoto[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  author       User         @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  booking      Booking      @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  listing      Listing      @relation(fields: [listingId], references: [id], onDelete: Cascade)
  targetUser   User         @relation("ReviewTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@unique([bookingId, authorId])
  @@index([listingId])
  @@index([targetUserId])
  @@index([status])
  @@index([createdAt])
}

/// Photos jointes aux avis
model ReviewPhoto {
  id        String   @id @default(cuid())
  reviewId  String
  url       String
  caption   String?
  position  Int      @default(0)
  createdAt DateTime @default(now())
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@index([reviewId])
}

/// Type d'avis
enum ReviewType {
  GUEST_TO_HOST   /// Voyageur note l'hôte/annonce
  HOST_TO_GUEST   /// Hôte note le voyageur
}

/// Statut de l'avis
enum ReviewStatus {
  PENDING     /// En attente de publication (période de 14 jours)
  PUBLISHED   /// Publié et visible
  FLAGGED     /// Signalé pour modération
  HIDDEN      /// Masqué par l'admin
  DELETED     /// Supprimé
}

model HostProfile {
  id                   String   @id @default(cuid())
  userId               String   @unique
  stripeAccountId      String?
  kycStatus            String   @default("incomplete")
  payoutsEnabled       Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  avatarUrl            String?
  bio                  String?
  /// Années d'expérience comme hôte
  experienceYears      Int?
  instagram            String?
  languages            String[] @default([])
  /// "moins_une_heure" | "quelques_heures" | "un_jour"
  responseTimeCategory String?
  superhost            Boolean  @default(false)
  verifiedEmail        Boolean  @default(false)
  verifiedPhone        Boolean  @default(false)
  website              String?
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([stripeAccountId])
}

model Wallet {
  id           String   @id @default(cuid())
  hostId       String   @unique
  balanceCents Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  host         User     @relation(fields: [hostId], references: [id], onDelete: Cascade)
}

model WalletLedger {
  id         String   @id @default(cuid())
  hostId     String
  deltaCents Int
  reason     String?
  bookingId  String?
  createdAt  DateTime @default(now())
  host       User     @relation(fields: [hostId], references: [id], onDelete: Cascade)

  @@index([hostId, createdAt])
}

model Amenity {
  id       String           @id @default(cuid())
  slug     String           @unique
  label    String
  category AmenityCategory  @default(GENERAL)
  listings ListingAmenity[]
}

model ListingAmenity {
  listingId String
  amenityId String
  createdAt DateTime @default(now())
  amenity   Amenity  @relation(fields: [amenityId], references: [id], onDelete: Cascade)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@id([listingId, amenityId])
}

model CalendarBlock {
  id        String              @id @default(cuid())
  listingId String
  start     DateTime
  end       DateTime
  reason    CalendarBlockReason @default(MANUAL_BLOCK)
  bookingId String?
  createdAt DateTime            @default(now())
  booking   Booking?            @relation(fields: [bookingId], references: [id])
  listing   Listing             @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId, start, end])
}

model Conversation {
  id            String    @id @default(cuid())
  /// contexte
  listingId     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  guestId       String
  /// participants
  hostId        String
  reservationId String?
  guest         User      @relation("GuestConversations", fields: [guestId], references: [id])
  host          User      @relation("HostConversations", fields: [hostId], references: [id])
  listing       Listing?  @relation(fields: [listingId], references: [id])
  booking       Booking?  @relation("BookingConversations", fields: [reservationId], references: [id])
  messages      Message[]

  @@index([hostId])
  @@index([guestId])
  @@index([reservationId])
  @@index([listingId])
}

model Message {
  id                String              @id @default(cuid())
  conversationId    String
  senderId          String
  createdAt         DateTime            @default(now())
  content           String
  readAt            DateTime?
  /// Langue detectee du message original (fr, en, es, etc.)
  originalLanguage  String?
  /// Traductions stockees en JSON { "fr": "...", "en": "...", "es": "..." }
  translations      Json?
  conversation      Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender            User                @relation(fields: [senderId], references: [id])
  MessageAttachment MessageAttachment[]

  @@index([conversationId, createdAt])
}

model StripeEvent {
  id          String   @id
  type        String
  processedAt DateTime @default(now())

  @@index([processedAt])
}

model SearchHistory {
  id          String   @id @default(cuid())
  userId      String
  destination String
  startDate   String?
  endDate     String?
  guests      Int?
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  read      Boolean          @default(false)
  readAt    DateTime?
  actionUrl String?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, read, createdAt])
}

model NotificationPreference {
  id                String   @id @default(cuid())
  userId            String   @unique
  emailEnabled      Boolean  @default(true)
  pushEnabled       Boolean  @default(true)
  smsEnabled        Boolean  @default(false)
  preferences       Json     @default("{}")
  doNotDisturbStart String?
  doNotDisturbEnd   String?
  timezone          String   @default("Europe/Paris")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Dispute {
  id                           String            @id @default(cuid())
  bookingId                    String
  openedById                   String
  againstId                    String
  reason                       DisputeReason
  status                       DisputeStatus     @default(OPEN)
  description                  String
  /// Montant réclamé par l'ouvreur (en centimes)
  claimedAmountCents           Int?
  /// Montant accordé après résolution (en centimes)
  awardedAmountCents           Int?
  assignedAdminId              String?
  /// Résolution finale (texte explicatif)
  resolution                   String?
  resolvedAt                   DateTime?
  /// Priorité (1 = urgent, 5 = basse)
  priority                     Int               @default(3)
  /// Catégorie de litige pour stats
  category                     DisputeCategory   @default(OTHER)
  /// Date limite de réponse pour la partie adverse
  responseDeadline             DateTime?
  /// La partie adverse a-t-elle répondu ?
  hasResponse                  Boolean           @default(false)
  /// Date de la dernière activité
  lastActivityAt               DateTime          @default(now())
  /// Nombre de jours depuis l'ouverture (calculé)
  /// Remboursement effectué ?
  refundProcessed              Boolean           @default(false)
  refundProcessedAt            DateTime?
  refundStripeId               String?
  /// Notes internes admin (non visibles par les parties)
  internalNotes                String?
  /// Escaladé au niveau supérieur ?
  isEscalated                  Boolean           @default(false)
  escalatedAt                  DateTime?
  escalationReason             String?
  createdAt                    DateTime          @default(now())
  updatedAt                    DateTime          @updatedAt
  User_Dispute_againstIdToUser User              @relation("Dispute_againstIdToUser", fields: [againstId], references: [id])
  assignedAdmin                User?             @relation("DisputeAdmin", fields: [assignedAdminId], references: [id])
  booking                      Booking           @relation(fields: [bookingId], references: [id])
  openedBy                     User              @relation("DisputeOpener", fields: [openedById], references: [id])
  evidence                     DisputeEvidence[]
  messages                     DisputeMessage[]
  timeline                     DisputeTimeline[]

  @@index([bookingId])
  @@index([openedById])
  @@index([assignedAdminId])
  @@index([againstId])
  @@index([status, priority])
  @@index([category])
  @@index([lastActivityAt])
}

/// Timeline des événements d'un litige
model DisputeTimeline {
  id        String              @id @default(cuid())
  disputeId String
  event     DisputeTimelineEvent
  actorId   String?
  details   String?
  metadata  Json?
  createdAt DateTime            @default(now())
  dispute   Dispute             @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  @@index([disputeId, createdAt])
}

/// Événements de la timeline d'un litige
enum DisputeTimelineEvent {
  OPENED
  RESPONSE_RECEIVED
  EVIDENCE_ADDED
  MESSAGE_SENT
  ADMIN_ASSIGNED
  STATUS_CHANGED
  ESCALATED
  MEDIATION_STARTED
  RESOLUTION_PROPOSED
  RESOLVED
  REFUND_PROCESSED
  CLOSED
  REOPENED
}

/// Catégorie de litige (pour stats et filtres)
enum DisputeCategory {
  REFUND_REQUEST
  PROPERTY_ISSUE
  HOST_BEHAVIOR
  GUEST_BEHAVIOR
  PAYMENT_PROBLEM
  CANCELLATION
  SAFETY
  OTHER
}

model DisputeEvidence {
  id           String   @id @default(cuid())
  disputeId    String
  uploadedById String
  fileUrl      String
  fileType     String
  fileName     String
  description  String?
  createdAt    DateTime @default(now())
  dispute      Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  uploadedBy   User     @relation(fields: [uploadedById], references: [id])

  @@index([disputeId])
}

model DisputeMessage {
  id        String   @id @default(cuid())
  disputeId String
  senderId  String
  content   String
  isAdmin   Boolean  @default(false)
  isSystem  Boolean  @default(false)
  createdAt DateTime @default(now())
  dispute   Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender    User     @relation(fields: [senderId], references: [id])

  @@index([disputeId, createdAt])
}

model AuditLog {
  id         String      @id @default(cuid())
  adminId    String
  action     AuditAction
  entityType String
  entityId   String
  details    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime    @default(now())
  admin      User        @relation(fields: [adminId], references: [id])

  @@index([action, createdAt])
  @@index([adminId, createdAt])
  @@index([entityType, entityId])
}

model PromoCode {
  id                     String           @id @default(cuid())
  code                   String           @unique
  type                   PromoType
  value                  Int
  maxUses                Int?
  usedCount              Int              @default(0)
  maxPerUser             Int              @default(1)
  minBookingAmountCents  Int?
  validFrom              DateTime         @default(now())
  validUntil             DateTime?
  firstBookingOnly       Boolean          @default(false)
  newUsersOnly           Boolean          @default(false)
  applicableListingTypes String[]         @default([])
  applicableCountries    String[]         @default([])
  isActive               Boolean          @default(true)
  createdById            String
  createdAt              DateTime         @default(now())
  User                   User             @relation(fields: [createdById], references: [id])
  usages                 PromoCodeUsage[]

  @@index([code, isActive])
  @@index([validUntil])
}

model PromoCodeUsage {
  id                  String    @id @default(cuid())
  promoCodeId         String
  userId              String
  bookingId           String?
  discountAmountCents Int
  usedAt              DateTime  @default(now())
  promoCode           PromoCode @relation(fields: [promoCodeId], references: [id], onDelete: Cascade)
  user                User      @relation(fields: [userId], references: [id])

  @@unique([promoCodeId, userId, bookingId])
  @@index([userId])
}

model Referral {
  id                     String    @id @default(cuid())
  referrerId             String
  referredId             String    @unique
  referrerBonusCents     Int       @default(0)
  referredBonusCents     Int       @default(0)
  referrerPaid           Boolean   @default(false)
  referredPaid           Boolean   @default(false)
  referredFirstBooking   Boolean   @default(false)
  referredFirstBookingAt DateTime?
  createdAt              DateTime  @default(now())
  referred               User      @relation("ReferralsReceived", fields: [referredId], references: [id])
  referrer               User      @relation("ReferralsMade", fields: [referrerId], references: [id])

  @@index([referrerId])
}

model DataExportRequest {
  id          String    @id @default(cuid())
  userId      String
  status      String    @default("pending")
  fileUrl     String?
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())
  completedAt DateTime?
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model AccountDeletionRequest {
  id          String    @id @default(cuid())
  userId      String
  reason      String?
  status      String    @default("pending")
  scheduledAt DateTime
  createdAt   DateTime  @default(now())
  processedAt DateTime?
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status, scheduledAt])
}

model SystemConfig {
  id          String   @id
  key         String   @unique
  value       Json
  category    String   @default("general")
  description String?
  updatedById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  User        User?    @relation(fields: [updatedById], references: [id])

  @@index([category])
}

model AdminNote {
  id         String   @id @default(cuid())
  targetType String
  targetId   String
  content    String
  isPinned   Boolean  @default(false)
  authorId   String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  author     User     @relation(fields: [authorId], references: [id])

  @@index([targetType, targetId])
  @@index([authorId])
}

model CalendarExport {
  id          String   @id
  listingId   String   @unique
  secretToken String   @unique
  createdAt   DateTime @default(now())
  Listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
}

model CalendarSync {
  id                  String    @id
  listingId           String
  externalUrl         String
  name                String
  lastSyncAt          DateTime?
  lastSyncStatus      String?
  lastSyncError       String?
  autoSync            Boolean   @default(true)
  syncIntervalMinutes Int       @default(60)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime
  Listing             Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([autoSync, lastSyncAt])
  @@index([listingId])
}

model DynamicPrice {
  id          String   @id
  listingId   String
  date        DateTime @db.Date
  dailyPrice  Float?
  hourlyPrice Float?
  minNights   Int?
  note        String?
  createdAt   DateTime @default(now())
  Listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@unique([listingId, date])
  @@index([listingId, date])
}

model Experience {
  id                String              @id
  hostId            String
  title             String
  description       String
  category          ExperienceCategory
  city              String
  country           String
  address           String?
  lat               Float?
  lng               Float?
  pricePerPerson    Int
  currency          Currency            @default(EUR)
  minGuests         Int                 @default(1)
  maxGuests         Int
  durationMinutes   Int
  includes          String[]            @default([])
  toBring           String[]            @default([])
  languages         String[]            @default(["fr"])
  status            ListingStatus       @default(DRAFT)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime
  User              User                @relation(fields: [hostId], references: [id])
  ExperienceBooking ExperienceBooking[]
  ExperienceImage   ExperienceImage[]
  ExperienceReview  ExperienceReview[]
  ExperienceSlot    ExperienceSlot[]

  @@index([category])
  @@index([city, country])
  @@index([hostId])
  @@index([status])
}

model ExperienceBooking {
  id                    String         @id
  experienceId          String
  slotId                String
  guestId               String
  guestCount            Int
  totalPriceCents       Int
  currency              Currency
  status                BookingStatus  @default(PENDING)
  stripePaymentIntentId String?
  messageToHost         String?
  createdAt             DateTime       @default(now())
  Experience            Experience     @relation(fields: [experienceId], references: [id])
  User                  User           @relation(fields: [guestId], references: [id])
  ExperienceSlot        ExperienceSlot @relation(fields: [slotId], references: [id])

  @@index([experienceId])
  @@index([guestId])
  @@index([slotId])
}

model ExperienceImage {
  id           String     @id
  experienceId String
  url          String
  isCover      Boolean    @default(false)
  position     Int        @default(0)
  Experience   Experience @relation(fields: [experienceId], references: [id], onDelete: Cascade)

  @@index([experienceId])
}

model ExperienceReview {
  id           String     @id
  experienceId String
  authorId     String
  rating       Int
  comment      String?
  createdAt    DateTime   @default(now())
  User         User       @relation(fields: [authorId], references: [id])
  Experience   Experience @relation(fields: [experienceId], references: [id], onDelete: Cascade)

  @@unique([experienceId, authorId])
  @@index([experienceId])
}

model ExperienceSlot {
  id                String              @id
  experienceId      String
  date              DateTime            @db.Date
  startTime         String
  availableSpots    Int
  bookedSpots       Int                 @default(0)
  priceOverride     Int?
  isActive          Boolean             @default(true)
  ExperienceBooking ExperienceBooking[]
  Experience        Experience          @relation(fields: [experienceId], references: [id], onDelete: Cascade)

  @@unique([experienceId, date, startTime])
  @@index([experienceId, date])
}

model ListingModeration {
  id              String        @id
  listingId       String        @unique
  status          ListingStatus @default(DRAFT)
  reviewedById    String?
  reviewedAt      DateTime?
  rejectionReason String?
  adminNotes      String?
  reportCount     Int           @default(0)
  isFeatured      Boolean       @default(false)
  featuredUntil   DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime
  Listing         Listing       @relation(fields: [listingId], references: [id], onDelete: Cascade)
  User            User?         @relation(fields: [reviewedById], references: [id])

  @@index([isFeatured])
  @@index([status])
}

model ListingReport {
  id         String   @id
  listingId  String
  reporterId String
  reason     String
  details    String?
  resolved   Boolean  @default(false)
  createdAt  DateTime @default(now())
  Listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  User       User     @relation(fields: [reporterId], references: [id])

  @@unique([listingId, reporterId])
  @@index([listingId])
  @@index([resolved])
}

model MessageAttachment {
  id            String   @id
  messageId     String
  fileUrl       String
  fileType      String
  fileName      String
  createdAt     DateTime @default(now())
  fileSizeBytes Int      @default(0)
  Message       Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

model PushSubscription {
  id        String   @id
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  createdAt DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model ReferralCode {
  id        String   @id
  userId    String   @unique
  code      String   @unique
  usedCount Int      @default(0)
  createdAt DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserBadge {
  id        String    @id
  userId    String
  type      BadgeType
  earnedAt  DateTime  @default(now())
  expiresAt DateTime?
  metadata  Json?
  User      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@index([userId])
}

model UserBan {
  id                            String    @id
  userId                        String
  bannedById                    String
  reason                        String
  expiresAt                     DateTime?
  isActive                      Boolean   @default(true)
  createdAt                     DateTime  @default(now())
  User_UserBan_bannedByIdToUser User      @relation("UserBan_bannedByIdToUser", fields: [bannedById], references: [id])
  User_UserBan_userIdToUser     User      @relation("UserBan_userIdToUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([userId, isActive])
}

model UserConsent {
  id        String   @id
  userId    String
  type      String
  version   String
  accepted  Boolean
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type, version])
  @@index([userId])
}

model UserPresence {
  id         String   @id
  userId     String   @unique
  isOnline   Boolean  @default(false)
  isTypingIn String?
  lastSeen   DateTime @default(now())
  User       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// Kit de récompense pour les hôtes Lok'Room
/// L'hôte doit choisir entre le Kit Essentiel (5 résas) ou attendre le Kit Super Hôte (25 résas)
model HostKit {
  id              String        @id @default(cuid())
  hostId          String        @unique
  host            User          @relation(fields: [hostId], references: [id], onDelete: Cascade)

  /// Type de kit choisi/réclamé
  kitType         HostKitType

  /// Statut du kit
  status          HostKitStatus @default(PENDING)

  /// Valeur affichée du kit (en centimes EUR)
  displayValueCents Int

  /// Nombre de réservations qualifiées au moment de la réclamation
  qualifyingBookings Int

  /// Date de qualification (quand l'hôte a atteint le seuil)
  qualifiedAt     DateTime

  /// Date de réclamation (quand l'hôte a fait son choix)
  claimedAt       DateTime      @default(now())

  /// Date d'expédition
  shippedAt       DateTime?

  /// Date de livraison
  deliveredAt     DateTime?

  /// Numéro de suivi
  trackingNumber  String?

  /// Adresse de livraison (JSON)
  shippingAddress Json

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([status])
}

/// Paramètres de réservation instantanée pour une annonce
model InstantBookSettings {
  id                    String   @id @default(cuid())
  listingId             String   @unique
  listing               Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  /// Critères d'acceptation automatique
  requireVerifiedId     Boolean  @default(false)  /// Guest doit avoir ID vérifié
  requirePositiveReviews Boolean @default(false)  /// Guest doit avoir des avis positifs
  minGuestRating        Float?                    /// Note minimum du guest (ex: 4.0)
  requireProfilePhoto   Boolean  @default(false)  /// Guest doit avoir une photo
  requirePhoneVerified  Boolean  @default(false)  /// Guest doit avoir téléphone vérifié

  /// Restrictions
  maxNights             Int?                      /// Nombre max de nuits
  minNights             Int?                      /// Nombre min de nuits
  advanceNoticeHours    Int      @default(24)     /// Préavis minimum en heures

  /// Message automatique
  autoMessage           String?                   /// Message envoyé automatiquement

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([listingId])
}

enum Role {
  HOST
  GUEST
  BOTH
  ADMIN
}

enum Currency {
  EUR
  CAD
  USD
  CNY
  GBP
}

enum ProvinceCA {
  AB
  BC
  ON
  QC
  NB
  NS
  NL
  PE
}

/// Provider de carte / autocomplétion d’adresse (Google Places, Mapbox, etc.)
enum MapProvider {
  GOOGLE
  MAPBOX
  OTHER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

/// Statut d'une annonce (workflow d'approbation)
enum ListingStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  REJECTED
  SUSPENDED
  ARCHIVED
}

/// Catégorie d'espace (Lok'Room : logements, bureaux, parkings, studios, etc.)
enum ListingType {
  ROOM
  STUDIO
  APARTMENT
  HOUSE
  OFFICE
  COWORKING
  MEETING_ROOM
  PARKING
  GARAGE
  STORAGE
  EVENT_SPACE
  RECORDING_STUDIO
  OTHER
}

/// Mode de tarification de l’espace
enum PricingMode {
  HOURLY
  DAILY
  BOTH
}

/// Raison d’un blocage dans le calendrier
enum CalendarBlockReason {
  BOOKING
  MANUAL_BLOCK
  MAINTENANCE
}

/// Catégorie d’amenity (wifi, parking, clim, etc.)
enum AmenityCategory {
  GENERAL
  BUSINESS
  PARKING
  ACCESSIBILITY
  OUTDOOR
  MEDIA
}

/// Statut de vérification d'identité Stripe Identity
enum IdentityVerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

/// Type de notification
enum NotificationType {
  BOOKING_REQUEST
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_REMINDER
  INSTANT_BOOK_CONFIRMED
  MESSAGE_NEW
  REVIEW_RECEIVED
  REVIEW_REMINDER
  PAYOUT_SENT
  PAYOUT_FAILED
  LISTING_APPROVED
  LISTING_REJECTED
  LISTING_SUSPENDED
  DISPUTE_OPENED
  DISPUTE_UPDATE
  DISPUTE_RESOLVED
  IDENTITY_VERIFIED
  IDENTITY_REJECTED
  SUPERHOST_EARNED
  SUPERHOST_LOST
  PROMO_CODE
  SYSTEM_ANNOUNCEMENT
  REFERRAL_BONUS
  // Notifications pour les dépôts de garantie (caution)
  SECURITY_DEPOSIT_AUTHORIZED
  SECURITY_DEPOSIT_RELEASED
  SECURITY_DEPOSIT_CAPTURED
  SECURITY_DEPOSIT_CLAIM_REQUEST
}

/// Statut du litige
enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  AWAITING_HOST
  AWAITING_GUEST
  MEDIATION
  RESOLVED_GUEST
  RESOLVED_HOST
  RESOLVED_PARTIAL
  CLOSED
  ESCALATED
}

/// Raison du litige
enum DisputeReason {
  PROPERTY_NOT_AS_DESCRIBED
  CLEANLINESS_ISSUE
  AMENITIES_MISSING
  HOST_UNRESPONSIVE
  GUEST_DAMAGE
  GUEST_VIOLATION
  PAYMENT_ISSUE
  CANCELLATION_DISPUTE
  SAFETY_CONCERN
  NOISE_COMPLAINT
  UNAUTHORIZED_GUESTS
  OTHER
}

/// Type d'action auditée
enum AuditAction {
  USER_CREATED
  USER_UPDATED
  USER_BANNED
  USER_UNBANNED
  USER_DELETED
  USER_ROLE_CHANGED
  USER_EMAIL_CHANGED
  USER_VERIFIED
  LISTING_APPROVED
  LISTING_REJECTED
  LISTING_SUSPENDED
  LISTING_UNSUSPENDED
  LISTING_DELETED
  LISTING_FEATURED
  BOOKING_CANCELLED_ADMIN
  BOOKING_REFUNDED
  DISPUTE_ASSIGNED
  DISPUTE_STATUS_CHANGED
  DISPUTE_RESOLVED
  DISPUTE_ESCALATED
  PAYOUT_APPROVED
  PAYOUT_REJECTED
  PAYOUT_MANUAL
  CONFIG_CHANGED
  PROMO_CREATED
  PROMO_DELETED
  ANNOUNCEMENT_SENT
  BADGE_GRANTED
  BADGE_REVOKED
  MESSAGE_DELETED
  CONVERSATION_DELETED
  NOTIFICATION_DELETED
  NOTIFICATIONS_BULK_DELETED
  HONEYPOT_TRIGGERED
  SECURITY_ALERT
  SUSPICIOUS_ACTIVITY
}

enum BadgeType {
  IDENTITY_VERIFIED
  EMAIL_VERIFIED
  PHONE_VERIFIED
  SUPERHOST
  EXPERIENCED_HOST
  QUICK_RESPONDER
  HIGHLY_RATED
  TRUSTED_GUEST
  EARLY_ADOPTER
  TOP_CONTRIBUTOR
}

enum ExperienceCategory {
  FOOD_DRINK
  ART_CULTURE
  SPORTS
  NATURE
  ENTERTAINMENT
  WELLNESS
  TOURS
  WORKSHOPS
  OTHER
}

enum PromoType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_SERVICE_FEE
}

/// Provider de paiement utilisé pour une réservation
enum PaymentProvider {
  STRIPE
  PAYPAL
}

/// Transaction PayPal pour une réservation
model PayPalTransaction {
  id              String   @id @default(cuid())
  bookingId       String
  booking         Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  /// PayPal Order ID
  orderId         String   @unique
  /// PayPal Capture ID (rempli après capture)
  captureId       String?
  /// PayPal Payer ID
  payerId         String?

  /// Montant en centimes
  amountCents     Int
  /// Devise (EUR, CAD, USD, etc.)
  currency        String   @default("EUR")
  /// Statut: CREATED, APPROVED, CAPTURED, REFUNDED, FAILED
  status          String

  /// Réponse brute PayPal (JSON)
  rawResponse     Json?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([bookingId])
  @@index([orderId])
  @@index([status])
}

/// Événement PayPal pour idempotence (similaire à StripeEvent)
model PayPalEvent {
  id          String   @id
  type        String
  processedAt DateTime @default(now())

  @@index([processedAt])
}

/// Type de kit hôte
enum HostKitType {
  ESSENTIAL   // Kit Essentiel - 5 réservations - Valeur 100€
  SUPERHOST   // Kit Super Hôte - 25 réservations - Valeur 250€
}

/// Statut du kit hôte
enum HostKitStatus {
  PENDING     // En attente de traitement
  PROCESSING  // En cours de préparation
  SHIPPED     // Expédié
  DELIVERED   // Livré
  CANCELLED   // Annulé
}

/// Statut du dépôt de garantie (caution)
enum SecurityDepositStatus {
  PENDING           // En attente de paiement
  AUTHORIZED        // Montant autorisé (hold)
  CAPTURED          // Montant capturé (dommages)
  RELEASED          // Montant libéré (pas de dommages)
  PARTIALLY_CAPTURED // Partiellement capturé
  FAILED            // Échec
  EXPIRED           // Expiré
}

/// Dépôt de garantie (caution) pour une réservation
model SecurityDeposit {
  id                    String                @id @default(cuid())
  bookingId             String                @unique
  booking               Booking               @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  /// Montant de la caution en centimes
  amountCents           Int
  currency              String                @default("EUR")
  status                SecurityDepositStatus @default(PENDING)

  /// Stripe PaymentIntent pour le hold
  stripePaymentIntentId String?
  /// Stripe Charge si capturé
  stripeChargeId        String?

  /// Capture partielle ou totale
  capturedAmountCents   Int?                  // Montant capturé en centimes
  captureReason         String?               // Raison de la capture
  capturedAt            DateTime?
  /// Photos des dommages (URLs)
  damagePhotos          String[]              @default([])

  /// Libération
  releasedAt            DateTime?

  /// Date d'expiration du hold Stripe
  expiresAt             DateTime

  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  @@index([status])
  @@index([expiresAt])
  @@index([stripePaymentIntentId])
}

/// Politique de dépôt de garantie pour une annonce
model SecurityDepositPolicy {
  id              String   @id @default(cuid())
  listingId       String   @unique
  listing         Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  /// Caution activée pour cette annonce
  enabled         Boolean  @default(false)
  /// Montant de la caution en centimes (200€ par défaut)
  amountCents     Int      @default(20000)
  currency        String   @default("EUR")

  /// Description pour le voyageur
  description     String?
  /// Nombre de jours après checkout pour libérer automatiquement
  refundDays      Int      @default(7)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

/// Conversation de support entre un utilisateur et l'équipe Lok'Room
model SupportConversation {
  id              String                  @id @default(cuid())
  userId          String
  user            User                    @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Admin assigné à cette conversation (null si pas encore pris en charge)
  assignedAdminId String?
  assignedAdmin   User?                   @relation("SupportAdmin", fields: [assignedAdminId], references: [id])

  /// Statut de la conversation
  status          SupportConversationStatus @default(WAITING_AGENT)

  /// Sujet/raison de la demande
  subject         String?

  /// Priorité (1 = urgent, 5 = basse)
  priority        Int                     @default(3)

  /// Date de prise en charge par un admin
  assignedAt      DateTime?

  /// Date de clôture
  closedAt        DateTime?

  /// Date du premier email de notification envoyé aux admins
  initialEmailSentAt    DateTime?

  /// Date du dernier rappel email envoyé (pour le rappel 15min)
  reminderEmailSentAt   DateTime?

  /// Email de confirmation d'assignation envoyé
  assignmentEmailSent   Boolean   @default(false)

  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt

  messages        SupportMessage[]

  @@index([userId])
  @@index([assignedAdminId])
  @@index([status])
  @@index([createdAt])
}

/// Message dans une conversation de support
model SupportMessage {
  id              String              @id @default(cuid())
  conversationId  String
  conversation    SupportConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  /// Expéditeur (utilisateur ou admin)
  senderId        String?
  sender          User?               @relation("SupportMessageSender", fields: [senderId], references: [id])

  /// Contenu du message
  content         String

  /// Type de message
  type            SupportMessageType  @default(USER)

  /// Lu par l'utilisateur
  readByUser      Boolean             @default(false)
  readByUserAt    DateTime?

  /// Lu par l'admin
  readByAdmin     Boolean             @default(false)
  readByAdminAt   DateTime?

  createdAt       DateTime            @default(now())

  @@index([conversationId, createdAt])
}

/// Statut d'une conversation de support
enum SupportConversationStatus {
  WITH_AI           /// En cours avec l'IA
  WAITING_AGENT     /// En attente d'un agent humain
  WITH_AGENT        /// Pris en charge par un agent
  RESOLVED          /// Résolu
  CLOSED            /// Fermé
}

/// Type de message de support
enum SupportMessageType {
  USER              /// Message de l'utilisateur
  AI                /// Message de l'IA
  ADMIN             /// Message d'un admin
  SYSTEM            /// Message système (ex: "Un agent va vous répondre")
}

/// Type d'accès à l'espace
enum SpaceAccessType {
  ENTIRE_PLACE      /// Logement entier
  PRIVATE_ROOM      /// Chambre privée
  SHARED_ROOM       /// Chambre partagée
  SHARED_SPACE      /// Espace partagé
}

/// Méthode de check-in
enum CheckInMethod {
  MEET_IN_PERSON    /// Rencontre en personne
  LOCKBOX           /// Boîte à clés
  KEYPAD            /// Clavier à code
  SMART_LOCK        /// Serrure connectée
  DOORMAN           /// Portier
  BUILDING_STAFF    /// Personnel de l'immeuble
}

/// Webhook pour intégrations tierces
model Webhook {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  url         String
  events      String[] /// ["booking.created", "booking.cancelled", etc.]
  secret      String   /// Pour HMAC signature
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deliveries  WebhookDelivery[]

  @@index([userId])
  @@index([active])
}

/// Livraison d'un webhook (historique)
model WebhookDelivery {
  id          String   @id @default(cuid())
  webhookId   String
  webhook     Webhook  @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  event       String
  payload     Json
  status      String   /// "pending", "success", "failed"
  attempts    Int      @default(0)
  lastAttempt DateTime?
  response    Json?
  createdAt   DateTime @default(now())

  @@index([webhookId])
  @@index([status])
  @@index([createdAt])
}

/// Backup de la base de données
model DatabaseBackup {
  id          String   @id @default(cuid())
  filename    String   @unique
  fileUrl     String   /// URL S3/R2
  fileSize    Int      /// Taille en bytes
  type        BackupType /// "daily", "weekly", "monthly"
  status      BackupStatus /// "pending", "completed", "failed"
  startedAt   DateTime
  completedAt DateTime?
  error       String?
  checksum    String?  /// SHA256 checksum pour vérification d'intégrité
  createdAt   DateTime @default(now())

  @@index([status])
  @@index([type])
  @@index([createdAt])
}

/// Type de backup
enum BackupType {
  DAILY
  WEEKLY
  MONTHLY
  MANUAL
}

/// Statut du backup
enum BackupStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  DELETED
}

/// Recommandation personnalisée pour un utilisateur
model UserRecommendation {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listingId   String
  listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  /// Score de pertinence (0-1)
  score       Float
  /// Raison de la recommandation
  reason      String
  createdAt   DateTime @default(now())

  @@unique([userId, listingId])
  @@index([userId, score])
  @@index([createdAt])
}

/// Comportement utilisateur pour le système de recommandations
model UserBehavior {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Type d'action: view, click, search, favorite, book
  action      String
  listingId   String?
  listing     Listing? @relation(fields: [listingId], references: [id], onDelete: SetNull)
  /// Métadonnées additionnelles (query, filters, etc.)
  metadata    Json?
  createdAt   DateTime @default(now())

  @@index([userId, createdAt])
  @@index([listingId])
  @@index([action])
}

/// Liste d'attente pour l'application mobile
model Waitlist {
  id        String   @id @default(cuid())
  email     String   @unique
  source    String   @default("mobile_app")
  createdAt DateTime @default(now())

  @@index([createdAt])
}
