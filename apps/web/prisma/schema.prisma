generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  GUEST
  HOST
  BOTH
  ADMIN
}

enum Currency {
  EUR
  CAD
  USD
  CNY
  GBP
}

enum ProvinceCA {
  AB
  BC
  ON
  QC
  NB
  NS
  NL
  PE
}

/// Provider de carte / autocompl√©tion d‚Äôadresse (Google Places, Mapbox, etc.)
enum MapProvider {
  GOOGLE
  MAPBOX
  OTHER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

/// Cat√©gorie d‚Äôespace (Lok'Room : logements, bureaux, parkings, studios, etc.)
enum ListingType {
  ROOM
  STUDIO
  APARTMENT
  HOUSE
  OFFICE
  COWORKING
  MEETING_ROOM
  PARKING
  GARAGE
  STORAGE
  EVENT_SPACE
  RECORDING_STUDIO
  OTHER
}

/// Mode de tarification de l‚Äôespace
enum PricingMode {
  HOURLY
  DAILY
  BOTH
}

/// Raison d‚Äôun blocage dans le calendrier
enum CalendarBlockReason {
  BOOKING
  MANUAL_BLOCK
  MAINTENANCE
}

/// Cat√©gorie d‚Äôamenity (wifi, parking, clim, etc.)
enum AmenityCategory {
  GENERAL
  BUSINESS
  PARKING
  ACCESSIBILITY
  OUTDOOR
  MEDIA
}

/// Statut de v√©rification d'identit√© Stripe Identity
enum IdentityVerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  emailVerified DateTime?

  role        Role         @default(GUEST)
  country     String?
  createdAt   DateTime     @default(now())
  lastLoginAt DateTime?
  profile     UserProfile?

  /// V√©rification d'identit√© Stripe Identity (Lok'Room)
  identityStatus          IdentityVerificationStatus @default(UNVERIFIED)
  identityLastVerifiedAt  DateTime?
  identityStripeSessionId String?

  accounts  Account[]
  sessions  Session[]
  Listing   Listing[]
  favorites Favorite[]

  /// R√©servations o√π l'user est le voyageur (guest)
  bookings Booking[] @relation("BookingGuest")

  /// R√©servations annul√©es par cet user (guest ou host)
  cancelledBookings Booking[] @relation("BookingCancelledBy")

  /// Avis √©crits par cet utilisateur
  reviewsWritten Review[] @relation("ReviewAuthor")

  /// Avis re√ßus par cet utilisateur (en tant qu‚Äôh√¥te ou guest)
  reviewsReceived Review[] @relation("ReviewTarget")

  hostProfile  HostProfile?
  wallet       Wallet?
  WalletLedger WalletLedger[]

  /// Messagerie
  messages           Message[]
  hostConversations  Conversation[] @relation("HostConversations")
  guestConversations Conversation[] @relation("GuestConversations")
}

model UserProfile {
  id          String  @id @default(cuid())
  user        User    @relation(fields: [userId], references: [id])
  userId      String  @unique
  avatarUrl   String?
  ratingAvg   Float   @default(0)
  ratingCount Int     @default(0)

  /// Champs suppl√©mentaires pour pr√©-remplir Stripe / profil Lok'Room
  firstName    String?
  lastName     String?
  birthDate    DateTime?
  phone        String?
  addressLine1 String?
  addressLine2 String?
  city         String?
  postalCode   String?
  country      String?
  province     String?
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Listing {
  id          String @id @default(cuid())
  title       String
  description String

  /// Type d‚Äôespace (chambre, bureau, parking, studio, etc.)
  type ListingType @default(OTHER)

  /// Mode de tarification (√† l‚Äôheure, √† la journ√©e, ou les deux)
  pricingMode PricingMode @default(DAILY)

  /// Prix par nuit / par jour (frontend d√©cidera comment l‚Äôafficher)
  price    Float
  currency Currency @default(EUR)

  /// Prix √† l‚Äôheure (optionnel, si l‚Äôespace est louable √† l‚Äôheure)
  hourlyPrice Float?

  /// Capacit√© de l‚Äôespace (nombre de personnes max)
  maxGuests Int?

  /// R√©servation instantan√©e possible ?
  isInstantBook Boolean @default(false)

  /// Contraintes de dur√©e pour les r√©servations √† l‚Äôheure
  minDurationHours Int?
  maxDurationHours Int?

  /// Contraintes de dur√©e pour les r√©servations √† la journ√©e / nuit√©e
  minNights Int?
  maxNights Int?

  country  String
  province ProvinceCA?

  /// Ville : obligatoire (d√©faut vide pour anciennes lignes)
  city String @default("")

  /// Adresse exacte de l‚Äôespace (jamais affich√©e publiquement)
  addressFull String @default("")

  /// Ligne d‚Äôadresse principale (num√©ro + rue)
  addressLine1 String?

  /// Code postal
  postalCode String?

  /// ID du lieu renvoy√© par le provider
  mapPlaceId String?

  /// Provider utilis√©
  mapProvider MapProvider @default(GOOGLE)

  /// Coordonn√©es exactes
  lat Float @default(0)
  lng Float @default(0)

  /// Coordonn√©es ‚Äúpubliques‚Äù (approx)
  latPublic Float @default(0)
  lngPublic Float @default(0)

  createdAt DateTime @default(now())

  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  images    ListingImage[]
  favorites Favorite[]
  bookings  Booking[]

  /// Avis associ√©s √† cette annonce
  reviews Review[]

  /// Commodit√©s / √©quipements
  amenities ListingAmenity[]

  /// Blocages calendrier (bookings + blocages manuels)
  calendar CalendarBlock[]

  /// Conversations li√©es √† cette annonce
  conversations Conversation[]

  @@index([ownerId])
  @@index([createdAt])
  @@index([country, province, city])
  @@index([mapPlaceId])
}

model ListingImage {
  id        String  @id @default(cuid())
  url       String
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  /// Image de couverture de l‚Äôannonce ?
  isCover Boolean @default(false)

  /// Ordre d‚Äôaffichage des images (0, 1, 2, ‚Ä¶)
  position Int @default(0)

  /// Dimensions de l‚Äôimage (optionnel, utile pour optimisation / thumbnails)
  width  Int?
  height Int?

  @@index([listingId])
  @@index([listingId, position])
  @@index([listingId, isCover])
}

model Favorite {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String
  createdAt DateTime @default(now())

  @@unique([userId, listingId])
  @@index([listingId])
  @@index([userId])
}

model Booking {
  id String @id @default(cuid())

  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  /// Voyageur (guest)
  guestId String
  guest   User   @relation("BookingGuest", fields: [guestId], references: [id])

  /// Mode de tarification utilis√© pour cette r√©servation (heure ou jour)
  pricingMode PricingMode

  /// Pour les r√©servations √† la journ√©e / nuit√©e
  startDate DateTime
  endDate   DateTime

  /// Pour les r√©servations √† l‚Äôheure :
  /// heures de d√©but/fin en minutes depuis minuit (dans le fuseau du listing)
  /// ex : 9h30 -> 570 ; 13h00 -> 780
  startTimeMinutes Int?
  endTimeMinutes   Int?
  timezone         String? // ex: "America/Montreal"

  /// Prix de base de la r√©servation (hors frais Lok'Room), dans la devise de l‚Äôannonce
  totalPrice Float
  currency   Currency

  status BookingStatus @default(PENDING)

  /// Stripe PaymentIntent (rempli au moment de la cr√©ation)
  stripePaymentIntentId String?

  /// Charge principale (remplie via webhook payment_intent.succeeded)
  stripeChargeId String?

  /// Infos d‚Äôannulation / refund
  cancelledAt       DateTime?
  cancelledByUserId String?
  cancelledByUser   User?     @relation("BookingCancelledBy", fields: [cancelledByUserId], references: [id])

  /// Montant total rembours√© au client (en cents, toutes devises confondues)
  refundAmountCents Int?

  /// D√©tail des frais Lok‚ÄôRoom (snapshot en cents au moment de la cr√©ation)
  hostFeeCents           Int @default(0) // commission prise sur l‚Äôh√¥te
  guestFeeCents          Int @default(0) // commission prise sur le guest
  taxOnGuestFeeCents     Int @default(0) // taxes collect√©es sur la part guest
  stripeFeeEstimateCents Int @default(0) // estimation des frais Stripe sur ce paiement
  platformNetCents       Int @default(0) // marge nette estim√©e (hostFee + guestFee + taxGuest - stripe)

  /// Avis li√©s √† cette r√©servation (guest et/ou host)
  reviews Review[]

  /// Blocages de calendrier li√©s √† cette r√©servation
  calendarBlocks CalendarBlock[]

  /// Conversations li√©es √† cette r√©servation
  conversations Conversation[] @relation("BookingConversations")

  createdAt DateTime @default(now())

  @@index([listingId, startDate, endDate])
  @@index([guestId, createdAt])
  @@index([stripePaymentIntentId])
}

model Review {
  id String @id @default(cuid())

  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  /// Auteur de l‚Äôavis (guest OU host)
  authorId String
  author   User   @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  /// Utilisateur vis√© par l‚Äôavis (souvent l‚Äôh√¥te, parfois le guest)
  targetUserId String
  targetUser   User   @relation("ReviewTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  /// Note 1‚Äì5
  rating Int

  /// Commentaire libre
  comment   String?
  createdAt DateTime @default(now())

  /// Un m√™me user ne peut laisser qu‚Äôun avis par booking
  @@unique([bookingId, authorId])
  @@index([listingId])
  @@index([targetUserId])
}

model HostProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Stripe / payouts
  stripeAccountId String?
  kycStatus       String  @default("incomplete")
  payoutsEnabled  Boolean @default(false)

  // üé® Personnalisation & identit√© host
  bio       String?  @db.Text
  avatarUrl String?
  languages String[] @default([])

  /// "moins_une_heure" | "quelques_heures" | "un_jour"
  responseTimeCategory String?

  verifiedPhone Boolean @default(false)
  verifiedEmail Boolean @default(false)
  superhost     Boolean @default(false)

  // Liens externes
  instagram String?
  website   String?

  /// Ann√©es d'exp√©rience comme h√¥te
  experienceYears Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stripeAccountId])
}

model Wallet {
  id     String @id @default(cuid())
  hostId String @unique
  host   User   @relation(fields: [hostId], references: [id], onDelete: Cascade)

  balanceCents Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model WalletLedger {
  id     String @id @default(cuid())
  hostId String
  host   User   @relation(fields: [hostId], references: [id], onDelete: Cascade)

  deltaCents Int
  reason     String?
  bookingId  String?
  createdAt  DateTime @default(now())

  @@index([hostId, createdAt])
}

// ======================================================================
// AMENITIES (commodit√©s / √©quipements)
// ======================================================================

model Amenity {
  id       String          @id @default(cuid())
  slug     String          @unique // "wifi", "parking", "climatisation"
  label    String // "Wifi", "Stationnement gratuit"
  category AmenityCategory @default(GENERAL)

  listings ListingAmenity[]
}

model ListingAmenity {
  listingId String
  amenityId String

  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  amenity Amenity @relation(fields: [amenityId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@id([listingId, amenityId])
}

// ======================================================================
// CALENDRIER ‚Äì blocages (bookings + blocages manuels)
// ======================================================================

model CalendarBlock {
  id        String  @id @default(cuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  start  DateTime
  end    DateTime
  reason CalendarBlockReason @default(MANUAL_BLOCK)

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([listingId, start, end])
}

// ======================================================================
// MESSAGERIE ‚Äì conversations & messages
// ======================================================================

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// participants
  hostId  String
  guestId String
  host    User   @relation("HostConversations", fields: [hostId], references: [id])
  guest   User   @relation("GuestConversations", fields: [guestId], references: [id])

  /// contexte
  listingId     String?
  listing       Listing? @relation(fields: [listingId], references: [id])
  reservationId String?
  booking       Booking? @relation("BookingConversations", fields: [reservationId], references: [id])

  /// messages
  messages Message[]

  @@index([hostId])
  @@index([guestId])
  @@index([reservationId])
}

model Message {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation(fields: [senderId], references: [id])

  content String

  @@index([conversationId, createdAt])
}
